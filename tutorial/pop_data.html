<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>1. Acquiring Population Data – RSTbx</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-a986a95301e671fce2c6472dffc862a1.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">RSTbx</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">Getting Started</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-tutorials" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Tutorials</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-tutorials">    
        <li>
    <a class="dropdown-item" href="../tutorial/pop_data.html">
 <span class="dropdown-text">1. Acquiring Population Data</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../tutorial/indiv_event_data.html">
 <span class="dropdown-text">2a. Preparing Individual-Level Event Data</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../tutorial/agg_event_data.html">
 <span class="dropdown-text">2b. Preparing Aggregate Event Data</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../tutorial/stab_rates.html">
 <span class="dropdown-text">3. Producing Stabilized Rates</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="../reference/index.html"> 
<span class="menu-text">Reference</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#requirements" id="toc-requirements" class="nav-link active" data-scroll-target="#requirements">Requirements</a>
  <ul class="collapse">
  <li><a href="#boundary-file" id="toc-boundary-file" class="nav-link" data-scroll-target="#boundary-file">Boundary file</a></li>
  <li><a href="#population-tables" id="toc-population-tables" class="nav-link" data-scroll-target="#population-tables">Population Tables</a></li>
  </ul></li>
  <li><a href="#using-custom-data" id="toc-using-custom-data" class="nav-link" data-scroll-target="#using-custom-data">Using custom data</a></li>
  <li><a href="#census-data-retriever-cdr" id="toc-census-data-retriever-cdr" class="nav-link" data-scroll-target="#census-data-retriever-cdr">Census Data Retriever (CDR)</a>
  <ul class="collapse">
  <li><a href="#producing-crude-rates" id="toc-producing-crude-rates" class="nav-link" data-scroll-target="#producing-crude-rates">Producing crude rates</a></li>
  <li><a href="#producing-age-adjusted-rates" id="toc-producing-age-adjusted-rates" class="nav-link" data-scroll-target="#producing-age-adjusted-rates">Producing age-adjusted rates</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">1. Acquiring Population Data</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>The first step in any RSTbx workflow is a boundary file and population data.</p>
<p>Luckly, the <a href="../reference/CDR.html">Census Data Retriever</a> can do both of those things for us!</p>
<section id="requirements" class="level2">
<h2 class="anchored" data-anchor-id="requirements">Requirements</h2>
<section id="boundary-file" class="level3">
<h3 class="anchored" data-anchor-id="boundary-file">Boundary file</h3>
<p>The RSTbx supports any geographic unit for which you can provide a boundary file for. Typically, people utilize Census boundary files for counties or tracts, which can be downloaded in <a href="https://www.census.gov/geographies/mapping-files/time-series/geo/tiger-line-file.html">TIGER</a> or <a href="https://www.census.gov/geographies/mapping-files/time-series/geo/cartographic-boundary.html">Cartographic</a> forms from the Census website.</p>
<p>There are three requirements of these boundary files:</p>
<ul>
<li>They should specify polygon/multipolygon boundaries.</li>
<li>There must be at least one column which must uniquely identify each region within the boundary file. These unique identifiers must be the same as those within the population table and the event table.</li>
<li>There should be no geographic regions within the boundary file which are not adjancent to at least one other area.</li>
</ul>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>Using Census TIGER boundaries rather than cartographic boundaries will mitigate the concern of geographic units without any adjacent areas, because TIGER boundaries represent political boundaries which span over water.</p>
</div>
</div>
</section>
<section id="population-tables" class="level3">
<h3 class="anchored" data-anchor-id="population-tables">Population Tables</h3>
<p>Population tables can come in two formats depending on your eventual goals. If you would like to produce crude rates, then the table should have one record (row) for each region. It would look something like this:</p>
<div class="table-auto">
<table class="caption-top table">
<thead>
<tr class="header">
<th style="text-align: left;">GEOID</th>
<th style="text-align: right;">PopulationCount</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">01001</td>
<td style="text-align: right;">59285</td>
</tr>
<tr class="even">
<td style="text-align: left;">01003</td>
<td style="text-align: right;">239945</td>
</tr>
<tr class="odd">
<td style="text-align: left;">01005</td>
<td style="text-align: right;">24757</td>
</tr>
<tr class="even">
<td style="text-align: left;">…</td>
<td style="text-align: right;">…</td>
</tr>
<tr class="odd">
<td style="text-align: left;">72149</td>
<td style="text-align: right;">21778</td>
</tr>
<tr class="even">
<td style="text-align: left;">72151</td>
<td style="text-align: right;">29868</td>
</tr>
<tr class="odd">
<td style="text-align: left;">72153</td>
<td style="text-align: right;">33509</td>
</tr>
</tbody>
</table>
</div>
<p>(Also see <strong>MI_pop</strong> within the <strong>data.gdb</strong>)</p>
<p>If you would like to produce age-adjusted rates, then the table should have one record for each region age-group combination. It would like something like this:</p>
<div class="table-auto">
<table class="caption-top table">
<thead>
<tr class="header">
<th style="text-align: left;">GEOID</th>
<th style="text-align: left;">AgeGroup</th>
<th style="text-align: right;">PopulationCount</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">01001</td>
<td style="text-align: left;">0-4</td>
<td style="text-align: right;">3430</td>
</tr>
<tr class="even">
<td style="text-align: left;">01001</td>
<td style="text-align: left;">5-14</td>
<td style="text-align: right;">7749</td>
</tr>
<tr class="odd">
<td style="text-align: left;">01001</td>
<td style="text-align: left;">15-24</td>
<td style="text-align: right;">7339</td>
</tr>
<tr class="even">
<td style="text-align: left;">…</td>
<td style="text-align: left;">…</td>
<td style="text-align: right;">…</td>
</tr>
<tr class="odd">
<td style="text-align: left;">72153</td>
<td style="text-align: left;">65-74</td>
<td style="text-align: right;">4527</td>
</tr>
<tr class="even">
<td style="text-align: left;">72153</td>
<td style="text-align: left;">75-84</td>
<td style="text-align: right;">3223</td>
</tr>
<tr class="odd">
<td style="text-align: left;">72153</td>
<td style="text-align: left;">85up</td>
<td style="text-align: right;">571</td>
</tr>
</tbody>
</table>
</div>
<p>(Also see <strong>MI_pop_grouped</strong> within the <strong>data.gdb</strong>)</p>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Important
</div>
</div>
<div class="callout-body-container callout-body">
<p>The following are valid age groups: “0-4”, “5-14”, “15-24”, “25-34”, “35-44”, “45-54”, “55-64”, “65-74”, “75-84”, “85up”. Within the population table they must be written exactly how they are listed here (i.e., “85 and up” would not be a valid age group).</p>
</div>
</div>
</section>
</section>
<section id="using-custom-data" class="level2">
<h2 class="anchored" data-anchor-id="using-custom-data">Using custom data</h2>
<p>Being able to use custom data within the RSTbx is a great asset.</p>
<p>One potential use of custom data within the RSTbx is to calculate rates at custom geographic regions. For example, if I wanted to calculate the heart disease death rate at <a href="https://www.dshs.texas.gov/regional-local-health-operations/public-health-regions">Texas Public Health Regions</a>, I could use a custom boundary file and population table to do so!</p>
<p>Another potential use is to calculate group-specific rates. For example, if I desired to calculate the heart disease death rate for females, I could filter down my event data to just female deaths and use a custom population table with total female population.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>The <a href="https://github.com/CEHI-code-repos/RSTr">RSTr package</a> has additional models which are more well suited to calculating group-specific rates. We encourage you to check the RSTr out if you are looking to calculating group-specific rates.</p>
</div>
</div>
<p>All the requirements above for your boundary file and population table will still hold even if you choose to use custom boundaries or population tables.</p>
</section>
<section id="census-data-retriever-cdr" class="level2">
<h2 class="anchored" data-anchor-id="census-data-retriever-cdr">Census Data Retriever (CDR)</h2>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>All succeeding tutorials will rely on custom data provided within the <strong>data.gdb</strong>, but this tutorial will help you become familiar with the CDR. You will not use this data in any of the other tutorials.</p>
</div>
</div>
<p>If you are looking to generate rates at the county (or county-equivalent) or tract level, the Census Data Retriever can prepare your data for you.</p>
<p>As discussed above, two pieces of data must be acquired as part of the first step of an RSTbx workflow: a boundary file and a population file.</p>
<p>Our eventual goal is to produce both crude and age-adjusted rates, so we will require a boundary file for both, a total population table, and an age-stratified table.</p>
<section id="producing-crude-rates" class="level3">
<h3 class="anchored" data-anchor-id="producing-crude-rates">Producing crude rates</h3>
<p>In order to create our crude rates, we will need a total population table. Let’s create one for Michigan counties using the 2015-2019 5-year ACS.</p>
<p>If you haven’t already, download and extract the latest release of the <a href="https://github.com/CEHI-code-repos/RateStabilizingToolbox/releases/latest">RSTbx</a>.</p>
<ol type="1">
<li><p>Open up ArcGIS Pro and create a new Map Project.</p></li>
<li><p>Open up the <strong>Catalog Pane</strong>.</p></li>
<li><p>Within the <strong>Catalog Pane</strong>, right click on <strong>Toolboxes</strong> and select <strong>Add Toolbox</strong>.</p></li>
<li><p>Navigate to where you have downloaded and extracted the RSTbx and find the <em>rate_stabilizing_toolbox.pyt</em>.</p></li>
<li><p>Open the <strong>Census Data Retriever</strong></p></li>
<li><p>Set the following parameters and <strong>Run</strong>:</p>
<p><strong>Age-Stratified</strong>: <em>Unchecked</em> (We only need total population numbers)<br>
<strong>Request Parameters</strong>:</p>
<ul>
<li><strong>Survey</strong>: <em>5-year ACS</em><br>
</li>
<li><strong>Year</strong>: <em>2015-2019</em><br>
</li>
<li><strong>Geography</strong>: <em>County</em><br>
</li>
<li><strong>State</strong>: <em>Michigan</em></li>
</ul>
<p><strong>Output Table</strong>: <em>mi_county_acs1519_pop</em></p></li>
</ol>
</section>
<section id="producing-age-adjusted-rates" class="level3">
<h3 class="anchored" data-anchor-id="producing-age-adjusted-rates">Producing age-adjusted rates</h3>
<p>Now that we have downloaded our total population table. We still require a age-stratified population table to calculate age-adjusted rates. Additionally, we still require boundaries. Fortunately, we can take care of both of these in one step.</p>
<ol type="1">
<li><p>Returning back to the <strong>Census Data Retriever</strong>, set the following parameters:</p>
<p><strong>Age-Stratified</strong>: <em>Checked</em> (We want an age-stratified table)</p>
<p>Keep all the <strong>Request Parameters</strong> the same:</p>
<ul>
<li><strong>Survey</strong>: <em>5-year ACS</em><br>
</li>
<li><strong>Year</strong>: <em>2015-2019</em><br>
</li>
<li><strong>Geography</strong>: <em>County</em><br>
</li>
<li><strong>State</strong>: <em>Michigan</em></li>
</ul>
<p><strong>Output Table</strong>: <em>mi_county_acs1519_pop_grouped</em></p>
<p>We also want to download our boundaries, so open up the <strong>Geography</strong> dropdown.</p>
<p>Set the <strong>Geometry Type</strong> to <em>Cartographic</em> and the <strong>Output Feature</strong> to <em>mi_county_carto</em>. <strong>Run</strong>.</p></li>
</ol>
<p>We have seen how the <strong>Census Data Retriever</strong> can be used to prepare population data, but we still need to prepare our event data. If you are interested in using individual, record level event data, consider moving on to <a href="../tutorial/indiv_event_data.html">2a. Preparing Individual-Level Event Data</a>. If you are interested in using aggregate event data, consider moving on to <a href="../tutorial/agg_event_data.html">2b. Preparing Aggregate Event Data</a>.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/CEHI-code-repos\.github\.io\/RateStabilizingToolbox\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>